<html><head><title>UVMC Converter Example - SV In-Transaction via Field Macros</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle></h1>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a name="UVMC_Converter_Example-SV_In-Transaction_via_Field_Macros"  href="../../../uvmc/examples/converters/sv_converter_trans_field_macros.sv">UVMC Converter Example - SV In-Transaction via Field Macros</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>This example shows a UVM-style transaction that uses the `uvm_field macros to implement the required conversion functionality.</td></tr>
  <!-- index=1 -->

<tr class="SGroup SIndent1"><td class=SEntry><a name="User_LibrarySummary"  href="#User_Library">User Library</a></td><td class=SDescription>This section defines a transaction class, <i>packet</i>, that indirectly extends <i>uvm_object</i>. </td></tr>
  <!-- index=2 -->

<tr class="SGroup SIndent1"><td class=SEntry><a name="Conversion_codeSummary"  href="#Conversion_code">Conversion code</a></td><td class=SDescription>This section is empty because our conversion functionality is built into the transaction type proper.</td></tr>
  <!-- index=3 -->

<tr class="SGroup SIndent1"><td class=SEntry><a name="Testbench_codeSummary"  href="#Testbench_code">Testbench code</a></td><td class=SDescription>This section defines our testbench environment. </td></tr></table></div></div><!--END_ND_SUMMARY-->
<div class=CBody><p>This example shows a UVM-style transaction that uses the `uvm_field macros to implement the required conversion functionality.</p><img src="../../../images/UVMC_Converters_SV_InTransMacros.png" width="388" height="128"><p>UVMC&rsquo;s default converter for SV works for these types of transactions.&nbsp; Direct implementation of the <i>do_pack</i> and <i>do_unpack</i> methods are preferred over using the <i>`uvm_field</i> macros because of the performance impact and low debug support associated with these macros.&nbsp; See &ldquo;Are UVM Macros Evil?&nbsp; A Cost Beneifit Analysis&rdquo; white paper for detailed analysis of the <i>`uvm_field</i> and other UVM macros.</p></div></div></div>




 <!--CONTENT index=1 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="User_Library" href="../../../uvmc/examples/converters/sv_converter_trans_field_macros.sv">User Library</a></h3><div class=CBody><p>This section defines a transaction class, <i>packet</i>, that indirectly extends <i>uvm_object</i>.&nbsp; It also defines a generic producer model via an `include.&nbsp; All transactions and components in the  user library should be written to be independent of context, i.e. not assume a UVMC or any other outside connetion.</p><p>The <i>`uvm_field</i> macros expand into hundreds of lines of code, perhaps thousands depending on the number and type of fields in your transaction.&nbsp; See the example showing direct implementation of <i>do_pack</i> and <i>do_unpack</i> for a better solution.</p><blockquote><pre>package user_pkg;

  `include &quot;uvm_macros.svh&quot;
  import uvm_pkg::*;

  class packet_base extends uvm_sequence_item;

    typedef enum { WRITE, READ, NOOP } cmd_t;

    rand cmd_t cmd;
    rand int   addr;
    rand byte  data[$];

    function new(string name=&quot;&quot;);
      super.new(name);
    endfunction

    constraint c_data_size { data.size() inside { [1:10] }; }

    `uvm_object_utils_begin(packet_base)
      `uvm_field_enum(cmd_t,cmd,UVM_ALL_ON)
      `uvm_field_int(addr,UVM_ALL_ON)
      `uvm_field_queue_int(data,UVM_ALL_ON)
    `uvm_object_utils_end

    virtual function string convert2string();
      return $sformatf(&quot;cmd:%s addr:%h data:%p&quot;,cmd,addr,data);
    endfunction

  endclass


  class packet extends packet_base;

    rand int extra_int;

    function new(string name=&quot;&quot;);
      super.new(name);
    endfunction

    `uvm_object_utils_begin(packet)
      `uvm_field_int(extra_int,UVM_ALL_ON)
    `uvm_object_utils_end

    virtual function string convert2string();
      return $sformatf(&quot;%s extra_int:%h&quot;,super.convert2string(),extra_int);
    endfunction

  endclass

  `include &quot;producer.sv&quot;

endpackage : user_pkg</pre></blockquote></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Conversion_code" href="../../../uvmc/examples/converters/sv_converter_trans_field_macros.sv">Conversion code</a></h3><div class=CBody><p>This section is empty because our conversion functionality is built into the transaction type proper.</p><blockquote><pre>/***  No external conversion code needed  ***/</pre></blockquote></div></div></div>




 <!--CONTENT index=3 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Testbench_code" href="../../../uvmc/examples/converters/sv_converter_trans_field_macros.sv">Testbench code</a></h3><div class=CBody><p>This section defines our testbench environment.&nbsp; In the env&rsquo;s <i>build</i> function, we instantiate the generic producer model.&nbsp; In the <i>connect</i> method, we register the producer&rsquo;s <i>out</i> port for UVMC connection using the lookup string &lsquo;stimulus&rsquo;.&nbsp; The SC-side will register its consumer&rsquo;s <i>in</i> port with the same lookup string.&nbsp; UVMC will match these two strings and complete the cross- language connection, i.e. the SV producer&rsquo;s <i>out</i> port will be bound to the SC consumer&rsquo;s <i>in</i> export.</p><p>Because our <i>packet</i> class implements the requisite <i>do_pack</i> and <i>do_unpack</i> methods, we can leverage UVMC&rsquo;s default converter, which delegates to these methods.&nbsp; When making the uvmc_tlm::connect call, we do not need to specify a custom converter type--only the transaction type.</p><blockquote><pre>module sv_main;

  `include &quot;uvm_macros.svh&quot;
  import uvm_pkg::*;
  import uvmc_pkg::*;
  import user_pkg::*;

  // Define env with connection specifying custom converter

  class sv_env extends uvm_env;

    producer #(packet) prod;

    `uvm_component_utils(sv_env)

    function new(string name, uvm_component parent=null);
       super.new(name,parent);
    endfunction

    function void build_phase(uvm_phase phase);
       prod = new(&quot;prod&quot;, this);
    endfunction

    function void connect_phase(uvm_phase phase);
      uvmc_tlm #(packet)::connect(prod.out, &quot;stimulus&quot;);
    endfunction

  endclass


  sv_env env;

  initial begin
    env = new(&quot;env&quot;);
    run_test();
  end

endmodule</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>