<html><head><title>UVMC Command API Examples - Common SV Code</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle></h1>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td class=SEntry><a name="UVMC_Command_API_Examples-Common_SV_Code"  href="../../../uvmc/examples/commands/sv_main.sv">UVMC Command API Examples - Common SV Code</a></td><td class=SDescription>This code provides an example of waiting for each UVM phase to reach a specified state and then, if the phase is a task phase, controlling its progression by raising and dropping the objection that governs it.</td></tr>
  <!-- index=1 -->

<tr class="SSMethod SMarked"><td class=SEntry><a name="prod_cfgSummary" id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')" href="#prod_cfg">prod_cfg</a></td><td class=SDescription>The <i>prod_cfg</i> class is the configuration object used by our <a href="#producer" class=LClass id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">producer</a> below. </td></tr>
  <!-- index=2 -->

<tr class="SSMethod"><td class=SEntry><a name="producerSummary" id=link3 onMouseOver="ShowTip(event, 'tt2', 'link3')" onMouseOut="HideTip('tt2')" href="#producer">producer</a></td><td class=SDescription>A simple SV producer TLM model that generates a configurable number of <i>uvm_tlm_generic_payload</i> transactions and sends them to its <i>out</i> port for execution. </td></tr>
  <!-- index=8 -->

<tr class="SSMethod SMarked"><td class=SEntry><a name="producer_extSummary" id=link4 onMouseOver="ShowTip(event, 'tt3', 'link4')" onMouseOut="HideTip('tt3')" href="#producer_ext">producer_ext</a></td><td class=SDescription>This trivial extension of our <a href="#producer" class=LClass id=link5 onMouseOver="ShowTip(event, 'tt2', 'link5')" onMouseOut="HideTip('tt2')">producer</a> class is used to demonstrate factory overrides from SC using the UVMC Command API.</td></tr>
  <!-- index=9 -->

<tr class="SSMethod"><td class=SEntry><a name="scoreboardSummary" id=link6 onMouseOver="ShowTip(event, 'tt4', 'link6')" onMouseOut="HideTip('tt4')" href="#scoreboard">scoreboard</a></td><td class=SDescription>A simple SV consumer TLM model that prints received transactions (of type ~tlm_generic_payload) and sends them out its <i>ap</i> analysis port.</td></tr>
  <!-- index=10 -->

<tr class="SSMethod SMarked"><td class=SEntry><a name="scoreboard_extSummary" id=link7 onMouseOver="ShowTip(event, 'tt5', 'link7')" onMouseOut="HideTip('tt5')" href="#scoreboard_ext">scoreboard_ext</a></td><td class=SDescription>This trivial extension of our <a href="#scoreboard" class=LClass id=link8 onMouseOver="ShowTip(event, 'tt4', 'link8')" onMouseOut="HideTip('tt4')">scoreboard</a> class is used to demonstrate factory overrides from SC using the UVMC Command API.</td></tr>
  <!-- index=11 -->

<tr class="SSMethod"><td class=SEntry><a name="envSummary" id=link9 onMouseOver="ShowTip(event, 'tt6', 'link9')" onMouseOut="HideTip('tt6')" href="#env">env</a></td><td class=SDescription>Our SV <i>env</i> contains an instance of our <a href="#producer" class=LClass id=link10 onMouseOver="ShowTip(event, 'tt2', 'link10')" onMouseOut="HideTip('tt2')">producer</a> and <a href="#scoreboard" class=LClass id=link11 onMouseOver="ShowTip(event, 'tt4', 'link11')" onMouseOut="HideTip('tt4')">scoreboard</a>, above.</td></tr>
  <!-- index=12 -->

<tr class="SModule SMarked"><td class=SEntry><a name="sv_mainSummary"  href="#sv_main">sv_main</a></td><td class=SDescription>This is the top-level module for the SV side of each command API example.</td></tr></table></div></div><!--END_ND_SUMMARY-->
<div class=CBody><p>This code provides an example of waiting for each UVM phase to reach a specified state and then, if the phase is a task phase, controlling its progression by raising and dropping the objection that governs it.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>uvmc_wait_for_phase</td><td class=CDLDescription>block until UVM has reached a certain phase.&nbsp; You may also wait for certain phase state (e.g. started, ended, etc.)</td></tr><tr><td class=CDLEntry>uvmc_raise_objection</td><td class=CDLDescription>prevent a UVM phase from ending</td></tr><tr><td class=CDLEntry>uvmc_drop_objection</td><td class=CDLDescription>remove your objection to ending a UVM phase</td></tr></table><p>See the <a href="../../src/connect/sc/uvmc_commands-h.html#Phasing" class=LGroup id=link12 onMouseOver="ShowTip(event, 'tt7', 'link12')" onMouseOut="HideTip('tt7')">Phasing</a> command descriptions for more details.</p></div></div></div>




 <!--CONTENT index=1 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="prod_cfg" href="../../../uvmc/examples/commands/sv_main.sv">prod_cfg</a></h2><div class=CBody><p>The <i>prod_cfg</i> class is the configuration object used by our <a href="#producer" class=LClass id=link15 onMouseOver="ShowTip(event, 'tt2', 'link15')" onMouseOut="HideTip('tt2')">producer</a> below.&nbsp; The <a href="ex_config-cpp.html#UVMC_Command_API_Example-Configuration" class=LSection id=link16 onMouseOver="ShowTip(event, 'tt8', 'link16')" onMouseOut="HideTip('tt8')">UVMC Command API Example - Configuration</a>  demonstrates how to set this configuration from the SC side.</p><p>The configuration object specifies various constraints on randomization of the generated transactions: the number of transactions, the address range, and limits on the size of the data array.</p><p>SV-side conversion is implemented inside the <i>do_pack</i> and <i>do_unpack</i> methods in the configuration object.</p><blockquote><pre>class prod_cfg extends uvm_object;

  `uvm_object_utils(prod_cfg);

  function new(string name=&quot;producer_config_inst&quot;);
    super.new(name);
  endfunction

  int min_addr = 'h00;
  int max_addr = 'hff;
  int min_data_len = 10;
  int max_data_len = 80;
  int max_trans = 5;

  virtual function void do_pack(uvm_packer packer);
    `uvm_pack_int(min_addr)
    `uvm_pack_int(max_addr)
    `uvm_pack_int(min_data_len)
    `uvm_pack_int(max_data_len)
    `uvm_pack_int(max_trans)
  endfunction

  virtual function void do_unpack(uvm_packer packer);
    `uvm_unpack_int(min_addr)
    `uvm_unpack_int(max_addr)
    `uvm_unpack_int(min_data_len)
    `uvm_unpack_int(max_data_len)
    `uvm_unpack_int(max_trans)
  endfunction

  function string convert2string();
    return $sformatf(&quot;min_addr:%h max_addr:%h min_data_len:%0d max_data_len:%0d max_trans:%0d&quot;,
    min_addr, max_addr, min_data_len, max_data_len,max_trans);
  endfunction

endclass</pre></blockquote></div></div></div>




 <!--CONTENT index=2 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="producer" href="../../../uvmc/examples/commands/sv_main.sv">producer</a></h2>

<!--START_ND_SUMMARY index=2-->
<div class=Summary><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=2 -->

<tr class="SClass"><td colspan=2 class=SEntry><a name="producerSummary" id=link17 onMouseOver="ShowTip(event, 'tt2', 'link17')" onMouseOut="HideTip('tt2')" href="#producer">producer</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>A simple SV producer TLM model that generates a configurable number of <i>uvm_tlm_generic_payload</i> transactions and sends them to its <i>out</i> port for execution. </td></tr>

  <!-- HIERARCHY -->
  <tr class="SHierarchy SIndent1 "><td colspan=2 class="SEntry SIndent1">Class Hierarchy</td></tr>
  <tr class="SPrototype SIndent1"><td colspan=2 class=SDescription>
      <div class=ClassHierarchy>
        <table border=0 cellspacing=0 cellpadding=0>
          <tr><td><div class=CHParent><div class=CHEntry>ovm_component</div></div></td></tr>
          <tr><td><div class=CHCurrent><div class=CHEntry>producer</div></div></td></tr>
        </table>
      </div>
  </td></tr>



  <!-- PROTOTYPE -->
  <tr class="SPrototype SIndent1"><td colspan=2 class="SEntry SIndent1">Class Declaration</td></tr>
  <tr class="SPrototype SIndent1"><td colspan=2 class=SDescription>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class producer extends uvm_component
  </td></tr></table></blockquote></td></tr>

  <!-- index=3 -->

<tr class="SGroup SIndent1"><td class=SEntry><a name="producer.MethodsSummary"  href="#producer.Methods">Methods</a></td><td class=SDescription></td></tr>
  <!-- index=4 -->

<tr class="SMethod SIndent2"><td class=SEntry><a name="producer.PhasesSummary"  href="#producer.Phases">Phases</a></td><td class=SDescription>We implement each phase to simply print a message that the phase has started. </td></tr>
  <!-- index=5 -->

<tr class="SMethod SIndent2 SMarked"><td class=SEntry><a name="producer.newSummary" id=link18 onMouseOver="ShowTip(event, 'tt9', 'link18')" onMouseOut="HideTip('tt9')" href="#producer.new">new</a></td><td class=SDescription>Creates a new producer object. </td></tr>
  <!-- index=6 -->

<tr class="SMethod SIndent2"><td class=SEntry><a name="producer.check_configSummary"  href="#producer.check_config">check_config</a></td><td class=SDescription></td></tr>
  <!-- index=7 -->

<tr class="SMethod SIndent2"><td class=SEntry><a name="producer.run_phaseSummary" id=link19 onMouseOver="ShowTip(event, 'tt10', 'link19')" onMouseOut="HideTip('tt10')" href="#producer.run_phase">run_phase</a></td><td class=SDescription>Produces the configured number of transactions, sending each to its <i>out</i> and <i>ap</i> analysis ports. </td></tr></table></div></div><!--END_ND_SUMMARY-->
<div class=CBody><p>A simple SV producer TLM model that generates a configurable number of <i>uvm_tlm_generic_payload</i> transactions and sends them to its <i>out</i> port for execution.&nbsp; The transaction is also broadcast to its <i>ap</i> analysis port.</p><p>While trivial in functionality, the model demonstrates use of TLM ports to facilitate external communication.</p><ul><li>Users of the model are not coupled to its internal implementation, using only the provided TLM ports to communicate.</li><li>The model itself does not refer to anything outside its encapsulated implementation.&nbsp; It does not know nor care about what might be receiving the transactions sent via its <i>out</i> and <i>ap</i> ports.</li></ul><p>Because this producer is used for all the Command API examples,  for</p></div></div></div>




 <!--CONTENT index=3 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="producer.Methods" href="../../../uvmc/examples/commands/sv_main.sv">Methods</a></h3></div></div>




 <!--CONTENT index=4 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="producer.Phases" href="../../../uvmc/examples/commands/sv_main.sv">Phases</a></h3><div class=CBody><p>We implement each phase to simply print a message that the phase has started.&nbsp; The <a href="ex_phase_control-cpp.html#UVMC_Command_API_Example-Phase_Control" class=LSection id=link20 onMouseOver="ShowTip(event, 'tt11', 'link20')" onMouseOut="HideTip('tt11')">UVMC Command API Example - Phase Control</a> will show that SC can be synchronized to UVM phases and even prevent the task phases from ending.</p><blockquote><pre>function void build_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;BUILD Started&quot;,UVM_NONE);
endfunction

function void connect_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;CONNECT Started&quot;,UVM_NONE);
endfunction

function void end_of_elaboration_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;END_OF_ELABORATION Started&quot;,UVM_NONE);
endfunction

function void start_of_simulation_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;START_OF_SIMULATION Started&quot;,UVM_NONE);
endfunction

task pre_reset_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;PRE_RESET Started&quot;,UVM_LOW);
endtask

task reset_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;RESET Started&quot;,UVM_LOW);
endtask

task post_reset_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;POST_RESET Started&quot;,UVM_LOW);
endtask

task pre_configure_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;PRE_CONFIGURE Started&quot;,UVM_LOW);
endtask

task configure_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;CONFIGURE Started&quot;,UVM_LOW);
endtask

task post_configure_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;POST_CONFIGURE Started&quot;,UVM_LOW);
endtask

task pre_main_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;PRE_MAIN Started&quot;,UVM_LOW);
endtask

task main_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;MAIN Started&quot;,UVM_LOW);
endtask

task post_main_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;POST_MAIN Started&quot;,UVM_LOW);
endtask

task pre_shutdown_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;PRE_SHUTDOWN Started&quot;,UVM_LOW);
endtask

task shutdown_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;SHUTDOWN Started&quot;,UVM_LOW);
endtask

task post_shutdown_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;POST_SHUTDOWN Started&quot;,UVM_LOW);
endtask

function void extract_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;EXTRACT Started&quot;,UVM_LOW);
endfunction

function void check_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;CHECK Started&quot;,UVM_LOW);
endfunction

function void report_phase(uvm_phase phase);
  `uvm_info(&quot;UVMC_PHASING&quot;,&quot;REPORT Started&quot;,UVM_LOW);
endfunction</pre></blockquote></div></div></div>




 <!--CONTENT index=5 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="producer.new" href="../../../uvmc/examples/commands/sv_main.sv">new</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters nowrap>function new(</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>name,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
</tr><tr><td></td>      <td class=PType nowrap>uvm_component&nbsp;</td>
      <td class=PParameter nowrap>parent</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
      <td class=PAfterParameters nowrap>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Creates a new producer object.&nbsp; Here, we allocate the <i>out</i> port and <i>ap</i> analysis port.&nbsp; If +PHASING_ON is not on the command line, we disable the UVMC_PHASING messages that are emitted by each phase callback (see above).</p><blockquote><pre>function new(string name, uvm_component parent=null);
   super.new(name,parent);
   out = new(&quot;out&quot;, this);
   analysis_out = new(&quot;analysis_out&quot;, this);
   if (!$test$plusargs(&quot;PHASING_ON&quot;))
     set_report_id_action(&quot;UVMC_PHASING&quot;,UVM_NO_ACTION);
endfunction : new


// Function: check_config
//
// Enabled only during the &lt;UVMC Command API Example - Configuration&gt;,
// the ~check_config~ function gets the configuration parameters
// that the SC side should have set. It produces ERRORs in cases
// where a get was not successful.

// (begin inline source)
prod_cfg cfg = new();

function void check_config();

  int i;
  string str;
  uvm_object obj;

    if (!uvm_config_db #(uvm_bitstream_t)::get(this,&quot;&quot;,&quot;some_int&quot;,i))
      `uvm_error(&quot;NO_INT_CONFIG&quot;,{&quot;No configuration for field 'some_int'&quot;,
         &quot; found at context '&quot;,get_full_name(),&quot;'&quot;})
    else
      `uvm_info(&quot;INT_CONFIG&quot;,
         $sformatf(&quot;Config for field 'some_int' at context '%s' has value %0h&quot;,
         get_full_name(),i),UVM_NONE)


    if (!uvm_config_db #(string)::get(this,&quot;&quot;,&quot;some_string&quot;,str))
      `uvm_error(&quot;NO_STRING_CONFIG&quot;,{&quot;No configuration for field 'some_string'&quot;,
         &quot; found at context '&quot;,get_full_name(),&quot;'&quot;})
    else
      `uvm_info(&quot;STRING_CONFIG&quot;,
         {&quot;Config for field 'message' at context '&quot;, get_full_name(),
         &quot;' has value '&quot;, str,&quot;'&quot;},UVM_NONE)

    if (!uvm_config_db #(uvm_object)::get(this,&quot;&quot;,&quot;config&quot;,obj))
      `uvm_error(&quot;NO_OBJECT_CONFIG&quot;,{&quot;No configuration for field 'config'&quot;,
         &quot; found at context '&quot;,get_full_name(),&quot;'&quot;})
    else begin
       prod_cfg c;
       if (!$cast(c,obj))
         `uvm_error(&quot;BAD_CONFIG_TYPE&quot;,
            {&quot;Object set for configuration field 'config' at context '&quot;,
            get_full_name(),&quot;' is not a prod_cfg type&quot;})
       else begin
         cfg = c;
         `uvm_info(&quot;OBJECT_CONFIG&quot;,
            {&quot;Config for field 'config' at context '&quot;,get_full_name(),
            &quot;' has value '&quot;, cfg.convert2string(),&quot;'&quot;},UVM_NONE)
       end
    end

endfunction</pre></blockquote></div></div></div>




 <!--CONTENT index=6 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="producer.check_config" href="../../../uvmc/examples/commands/sv_main.sv">check_config</a></h3><div class=CBody><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>Enabled only during the &lt;UVMC Command API Example</td><td class=CDLDescription>Configuration&gt;, the <i>check_config</i> function gets the configuration parameters that the SC side should have set.&nbsp; It produces ERRORs in cases where a get was not successful.</td></tr></table></div></div></div>




 <!--CONTENT index=7 -->
<div class="CMethod"><div class=CTopic><h3 class=CTitle><a name="producer.run_phase" href="../../../uvmc/examples/commands/sv_main.sv">run_phase</a></h3>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters nowrap>task run_phase (</td>      <td class=PType nowrap>uvm_phase&nbsp;</td>
      <td class=PParameter nowrap>phase</td>
      <td class=PAfterParameters nowrap>)</td></tr>
      </table></td></tr>
    </table></blockquote>
<div class=CBody><p>Produces the configured number of transactions, sending each to its <i>out</i> and <i>ap</i> analysis ports.&nbsp; A <a href="#prod_cfg" class=LClass id=link21 onMouseOver="ShowTip(event, 'tt1', 'link21')" onMouseOut="HideTip('tt1')">prod_cfg</a> configuration object governs how many transactions are produced and constrains the address range and data array length during randomization.&nbsp; Upon return from sending the last transaction, the producer drops its objection to ending the run_phase, thus allowing simulation to proceed to the next phase.</p><blockquote><pre>   task run_phase (uvm_phase phase);

     uvm_tlm_generic_payload pkt = new;
     uvm_tlm_time delay = new;

     bit enable_config_check = $test$plusargs(&quot;CONFIG_ON&quot;);
     bit enable_stimulus = $test$plusargs(&quot;TRANS_ON&quot;);
     pkt.m_streaming_width.rand_mode(0);
     pkt.m_byte_enable_length.rand_mode(0);
     pkt.m_byte_enable.rand_mode(0);
     pkt.m_data = new[1];

     `uvm_info(&quot;UVMC_PHASING&quot;,&quot;RUN Started&quot;,UVM_LOW);

     phase.raise_objection(this);

     if (enable_config_check)
       check_config();

     if (enable_stimulus &amp;&amp; cfg != null) begin

       for (int i = 1; i &lt;= cfg.max_trans; i++) begin

         if (!pkt.randomize() with {
            m_address inside { [cfg.min_addr:cfg.max_addr] };
            m_data.size() inside { [cfg.min_data_len:cfg.max_data_len] }; })
           `uvm_error(&quot;RAND_FAILED&quot;,  &quot;Randomization of tlm_gp failed&quot;)

         pkt.set_data_length(pkt.m_data.size());

         delay.set_abstime(11,1e-9);

         $display();
         `uvm_info(&quot;PRODUCER/SEND_PKT&quot;,
            $sformatf(&quot;SV producer sending packet #%0d\n  %s&quot;,i,
                      pkt.sprint(uvm_default_line_printer)),UVM_MEDIUM)

         analysis_out.write(pkt);
         out.b_transport(pkt,delay);
       end

     end

     #1000;

     `uvm_info(&quot;PRODUCER/STOP_TEST&quot;,&quot;Stopping the test&quot;,UVM_LOW)
     phase.drop_objection(this);

   endtask

endclass</pre></blockquote></div></div></div>




 <!--CONTENT index=8 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="producer_ext" href="../../../uvmc/examples/commands/sv_main.sv">producer_ext</a></h2><div class=CBody><p>This trivial extension of our <a href="#producer" class=LClass id=link25 onMouseOver="ShowTip(event, 'tt2', 'link25')" onMouseOut="HideTip('tt2')">producer</a> class is used to demonstrate factory overrides from SC using the UVMC Command API.</p><blockquote><pre>class producer_ext extends producer;

   `uvm_component_utils(producer_ext)

   function new(string name, uvm_component parent=null);
      super.new(name,parent);
      `uvm_info(&quot;PRODUCER_EXTENSION&quot;,&quot;Derived producer created!&quot;,UVM_NONE);
   endfunction

endclass</pre></blockquote></div></div></div>




 <!--CONTENT index=9 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="scoreboard" href="../../../uvmc/examples/commands/sv_main.sv">scoreboard</a></h2><div class=CBody><p>A simple SV consumer TLM model that prints received transactions (of type ~tlm_generic_payload) and sends them out its <i>ap</i> analysis port.</p><p>While trivial in functionality, the model demonstrates use of TLM ports to facilitate external communication.</p><ul><li>Users of the model are not coupled to its internal implementation, using only the provided TLM exports to communicate.</li><li>The model itself does not refer to anything outside its encapsulated implementation.&nbsp; It does not know nor care about what might be driving its analysis exports.</li></ul></div></div></div>




 <!--CONTENT index=10 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="scoreboard_ext" href="../../../uvmc/examples/commands/sv_main.sv">scoreboard_ext</a></h2><div class=CBody><p>This trivial extension of our <a href="#scoreboard" class=LClass id=link30 onMouseOver="ShowTip(event, 'tt4', 'link30')" onMouseOut="HideTip('tt4')">scoreboard</a> class is used to demonstrate factory overrides from SC using the UVMC Command API.</p><blockquote><pre>class scoreboard_ext extends scoreboard;

   `uvm_component_utils(scoreboard_ext)

   function new(string name, uvm_component parent=null);
      super.new(name,parent);
      `uvm_info(&quot;SCOREBOARD_EXTENSION&quot;,&quot;Derived scoreboard created!&quot;,UVM_NONE);
   endfunction

endclass</pre></blockquote></div></div></div>




 <!--CONTENT index=11 -->
<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="env" href="../../../uvmc/examples/commands/sv_main.sv">env</a></h2><div class=CBody><p>Our SV <i>env</i> contains an instance of our <a href="#producer" class=LClass id=link34 onMouseOver="ShowTip(event, 'tt2', 'link34')" onMouseOut="HideTip('tt2')">producer</a> and <a href="#scoreboard" class=LClass id=link35 onMouseOver="ShowTip(event, 'tt4', 'link35')" onMouseOut="HideTip('tt4')">scoreboard</a>, above.</p><blockquote><pre>class env extends uvm_env;

   `uvm_component_utils(env)

   uvm_tlm_b_transport_port #(uvm_tlm_generic_payload) prod_out;
   uvm_analysis_export #(uvm_tlm_generic_payload) sb_actual_in;

   producer prod;
   scoreboard sb;

   function new(string name, uvm_component parent=null);
     super.new(name,parent);
     prod_out = new(&quot;prod_out&quot;,this);
     sb_actual_in = new(&quot;sb_actual_in&quot;,this);
   endfunction

   function void build();
     prod = producer::type_id::create(&quot;prod&quot;,this);
     sb = scoreboard::type_id::create(&quot;sb&quot;,this);
   endfunction

   function void connect();
     prod.analysis_out.connect(sb.expect_in);
     prod.out.connect(prod_out);
     sb_actual_in.connect(sb.actual_in);
   endfunction

endclass</pre></blockquote></div></div></div>




 <!--CONTENT index=12 -->
<div class="CModule"><div class=CTopic><h2 class=CTitle><a name="sv_main" href="../../../uvmc/examples/commands/sv_main.sv">sv_main</a></h2><div class=CBody><p>This is the top-level module for the SV side of each command API example.</p><p>This top-level SV module does the following</p><ul><li>Initializes the UVMC Command API layer by calling <i>uvmc_init</i>.&nbsp; This is required.&nbsp; You can also relegate the init call to a separate module that is compiled separately or on the same command line as this file.</li><li>Registers the env&rsquo;s <i>prod_out</i> and <i>sb_actual_in</i> ports for UVMC communication.</li><li>Calls <i>run_test</i> to start the SV portion of the simulation.</li></ul><p>We could have registered the UVMC connections in the <a href="#env" class=LClass id=link36 onMouseOver="ShowTip(event, 'tt6', 'link36')" onMouseOut="HideTip('tt6')">env&rsquo;s</a> <i>connect</i> method, but that would have forced the <i>env</i> to only work with UVMC.&nbsp; If you prefer to relagate UVMC registration to the <a href="#env" class=LClass id=link37 onMouseOver="ShowTip(event, 'tt6', 'link37')" onMouseOut="HideTip('tt6')">env</a> or lower, you should not mix it in with the <i>env&rsquo;s</i> main purpose.&nbsp; Instead, try to add the UVMC connection code to a simple extension/wrapper around your original model.&nbsp; This technique is demonstrated in &lt;SC to SV Connection-SC side).</p><blockquote><pre>module sv_main;

  import uvmc_pkg::*;

  env e;

  // Must initialize
  initial
    uvmc_init();

  initial begin
    e = new(&quot;e&quot;);

    $timeformat(-9,0,&quot; ns&quot;);

    // actual path - SC-side consumer to SV-side scoreboard
    uvmc_tlm #(uvm_tlm_generic_payload)::connect(e.prod_out,&quot;foo&quot;);
    uvmc_tlm1 #(uvm_tlm_generic_payload)::connect(e.sb_actual_in,&quot;bar&quot;);

    run_test();

  end

endmodule</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class prod_cfg extends uvm_object
  </td></tr></table></blockquote>The <i>prod_cfg</i> class is the configuration object used by our producer below. </div></div><div class=CToolTip id="tt2"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class producer extends uvm_component
  </td></tr></table></blockquote>A simple SV producer TLM model that generates a configurable number of <i>uvm_tlm_generic_payload</i> transactions and sends them to its <i>out</i> port for execution. </div></div><div class=CToolTip id="tt3"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class producer_ext extends producer
  </td></tr></table></blockquote>This trivial extension of our producer class is used to demonstrate factory overrides from SC using the UVMC Command API.</div></div><div class=CToolTip id="tt4"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class scoreboard extends uvm_component
  </td></tr></table></blockquote>A simple SV consumer TLM model that prints received transactions (of type ~tlm_generic_payload) and sends them out its <i>ap</i> analysis port.</div></div><div class=CToolTip id="tt5"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class scoreboard_ext extends scoreboard
  </td></tr></table></blockquote>This trivial extension of our scoreboard class is used to demonstrate factory overrides from SC using the UVMC Command API.</div></div><div class=CToolTip id="tt6"><div class=CClass>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype><tr><td>class env extends uvm_env
  </td></tr></table></blockquote>Our SV <i>env</i> contains an instance of our producer and scoreboard, above.</div></div><div class=CToolTip id="tt7"><div class=CGroup>An API that provides access UVM&rsquo;s phase state and the objection objects used to control phase progression.</div></div><div class=CToolTip id="tt8"><div class=CSection>This example demonstrates usage the set_config and get_config portion of the UVMC Command API.</div></div><div class=CToolTip id="tt9"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters nowrap>function new(</td>      <td class=PType nowrap>string&nbsp;</td>
      <td class=PParameter nowrap>name,</td>
      <td class=PDefaultValuePrefix>&nbsp;&nbsp;</td>
      <td class=PDefaultValue width=100%></td>
</tr><tr><td></td>      <td class=PType nowrap>uvm_component&nbsp;</td>
      <td class=PParameter nowrap>parent</td>
      <td class=PDefaultValuePrefix>&nbsp;=&nbsp;</td>
      <td class=PDefaultValue width=100%>null</td>
      <td class=PAfterParameters nowrap>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Creates a new producer object. </div></div><div class=CToolTip id="tt10"><div class=CMethod>
    <blockquote><table border=0 cellspacing=0 cellpadding=0 class=Prototype>
      <tr><td><table border=0 cellspacing=0 cellpadding=0><tr>
      <td class=PBeforeParameters nowrap>task run_phase (</td>      <td class=PType nowrap>uvm_phase&nbsp;</td>
      <td class=PParameter nowrap>phase</td>
      <td class=PAfterParameters nowrap>)</td></tr>
      </table></td></tr>
    </table></blockquote>
Produces the configured number of transactions, sending each to its <i>out</i> and <i>ap</i> analysis ports. </div></div><div class=CToolTip id="tt11"><div class=CSection>This code provides an example of waiting for each UVM phase to reach a specified state and then, if the phase is a task phase, controlling its progression by raising and dropping the objection that governs it.</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>