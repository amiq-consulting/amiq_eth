<html><head><title>UVMC Connections</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle></h1>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a name="UVMC_Connections"  href="../../../uvmc/examples/connections/README.txt">UVMC Connections</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>This chapter shows how to make TLM connections between SystemC and SystemVerilog UVM components.</td></tr>
  <!-- index=1 -->

<tr class="SGroup SIndent1"><td class=SEntry><a name="OverviewSummary"  href="#Overview">Overview</a></td><td class=SDescription>To communicate, verification components must agree on the data they are exchanging and the interface used to exchange that data. </td></tr>
  <!-- index=2 -->

<tr class="SGroup SIndent1"><td class=SEntry><a name="The_Connect_FunctionSummary"  href="#The_Connect_Function">The Connect Function</a></td><td class=SDescription>The <i>connect</i> and <i>connect_hier</i> functions are used to register any type of TLM port, export, interface, imp, or socket for connection across the language boundary.</td></tr>
  <!-- index=3 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a name="SyntaxSummary"  href="#Syntax">Syntax</a></td><td class=SDescription>The calling syntax for the <i>connect</i> function.</td></tr>
  <!-- index=4 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a name="ParametersSummary"  href="#Parameters">Parameters</a></td><td class=SDescription>A description of the type parameters to <i>connect</i>.</td></tr>
  <!-- index=5 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a name="ArgumentsSummary"  href="#Arguments">Arguments</a></td><td class=SDescription>A description of the arguments to <i>connect</i>.</td></tr>
  <!-- index=6 -->

<tr class="SGroup SIndent1"><td class=SEntry><a name="UsageSummary"  href="#Usage">Usage</a></td><td class=SDescription>The <i>connect</i> function registers a port for UVMC connection. </td></tr>
  <!-- index=7 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a name="SV_ConnectionsSummary"  href="#SV_Connections">SV Connections</a></td><td class=SDescription>For SV, the connect function is a static member function of a class that is parameterized to the transaction type and optional converter. </td></tr>
  <!-- index=8 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a name="SC_ConnectionsSummary"  href="#SC_Connections">SC Connections</a></td><td class=SDescription>UVMC connections in SystemC are made by registering any TLM port, export, interface, or socket using the <i>uvmc_connect</i> function. </td></tr>
  <!-- index=9 -->

<tr class="SGroup SIndent1"><td class=SEntry><a name="NotesSummary"  href="#Notes">Notes</a></td><td class=SDescription></td></tr>
  <!-- index=10 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a name="One_UVMC_Connection_per_PortSummary"  href="#One_UVMC_Connection_per_Port">One UVMC Connection per Port</a></td><td class=SDescription>A UVMC connect call can be made only once for each port, export, imp, and socket instance, but this restriction does not limit your connectivity options. </td></tr>
  <!-- index=11 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a name="SC_connections_without_sc_mainSummary"  href="#SC_connections_without_sc_main">SC connections without sc_main</a></td><td class=SDescription>All SC examples in this kit all define the standard <i>sc_main</i> entry point to instantiate the SC-side testbench and start SystemC. </td></tr>
  <!-- index=12 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a name="SystemC_Starting_before_UVM_is_ReadySummary"  href="#SystemC_Starting_before_UVM_is_Ready">SystemC Starting before UVM is Ready</a></td><td class=SDescription>SystemC may finish elaboration before SystemVerilog, in which case its models may start to emit transactions out its UVMC ports connections before UVM is ready to receive them. </td></tr>
  <!-- index=13 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a name="TimescalesSummary"  href="#Timescales">Timescales</a></td><td class=SDescription>UVM Connect&rsquo;s default time precision for conveying delay times in the TLM2 interfaces is 1 picosecond.</td></tr>
  <!-- index=14 -->

<tr class="SGroup SIndent1"><td class=SEntry><a name="Connection_ExamplesSummary"  href="#Connection_Examples">Connection Examples</a></td><td class=SDescription>This section describes how to prepare and run the connection examples including in this kit.</td></tr>
  <!-- index=15 -->

<tr class="SGeneric SIndent2 SMarked"><td class=SEntry><a name="SetupSummary"  href="#Setup">Setup</a></td><td class=SDescription>See <a href="../../docs/OVERVIEW-txt.html#Getting_Started" class=LGroup id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">Getting Started</a> for setup requirements before running the examples. </td></tr>
  <!-- index=16 -->

<tr class="SGeneric SIndent2"><td class=SEntry><a name="RunningSummary"  href="#Running">Running</a></td><td class=SDescription></td></tr></table></div></div><!--END_ND_SUMMARY-->
<div class=CBody><p>This chapter shows how to make TLM connections between SystemC and SystemVerilog UVM components.</p></div></div></div>




 <!--CONTENT index=1 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Overview" href="../../../uvmc/examples/connections/README.txt">Overview</a></h3><div class=CBody><p>To communicate, verification components must agree on the data they are exchanging and the interface used to exchange that data.&nbsp; This chapter covers how to make connections between components using standard TLM interfaces.</p><p>This chapter focuses on connections.&nbsp; The code to make the connections look the same regardless of the types of the TLM interfaces being connected.&nbsp; We do not need to show the actual types of the ports, exports, or sockets used by the models we are connecting.&nbsp; The only requirement is that the port types be compatible.&nbsp; If they are not, the C++ or SystemVerilog compiler or elaborator will let us know.</p><p>All the examples in this section use the TLM2 generic transaction type, <i>tlm_generic_payload</i> (TLM GP), for which transaction type and converters are pre-defined for you.&nbsp; Greater reuse and interoperability is possible for models that use the TLM GP and follow the TLM base protocol, both of which are defined in IEEE 1666-2011.</p></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="The_Connect_Function" href="../../../uvmc/examples/connections/README.txt">The Connect Function</a></h3><div class=CBody><p>The <i>connect</i> and <i>connect_hier</i> functions are used to register any type of TLM port, export, interface, imp, or socket for connection across the language boundary.</p></div></div></div>




 <!--CONTENT index=3 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Syntax" href="../../../uvmc/examples/connections/README.txt">Syntax</a></h3><div class=CBody><p>The calling syntax for the <i>connect</i> function.</p><h4 class=CHeading>SV</h4><blockquote><pre>TLM2
 uvmc_tlm #(T, CVRT)::connect (port, lookup);
 uvmc_tlm #(T, CVRT)::connect_hier (port, lookup);

TLM1:
 uvmc_tlm1 #(T, CVRT)::connect (port, lookup);
 uvmc_tlm1 #(REQ,RSP,CVRT_REQ,CVRT_RSP)::connect (port,lookup);

 uvmc_tlm1 #(T, CVRT)::connect_hier (port, lookup); TLM1 uni
 uvmc_tlm1 #(REQ,RSP,CVRT_REQ,CVRT_RSP)::connect_hier (port,lookup);</pre></blockquote><h4 class=CHeading>SC</h4><blockquote><pre>TLM1 &amp; TLM2:
 uvmc_connect (port, lookup);
 uvmc_connect &lt;CVRT&gt; (port, lookup);

 uvmc_connect_hier (port, lookup);
 uvmc_connect_hier &lt;CVRT&gt; (port, lookup);</pre></blockquote></div></div></div>




 <!--CONTENT index=4 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Parameters" href="../../../uvmc/examples/connections/README.txt">Parameters</a></h3><div class=CBody><p>A description of the type parameters to <i>connect</i>.</p><p>The <i>connect</i> function is a static function accessed via a class with type parameters for <i>T</i>, the transaction type, and optional <i>CVRT</i>, a custom converter type.&nbsp; References to <i>port</i> in the following descriptions refer to all port types, i.e. ports, exports, sockets, etc., unless otherwise noted.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>T</td><td class=CDLDescription>Specifies the transaction type for all TLM2 ports and unidirectional TLM1 ports.&nbsp; Required parameter for SV connections.</td></tr><tr><td class=CDLEntry>REQ, RSP</td><td class=CDLDescription>Specifies the request and response transaction types for bidirectional TLM1 ports.&nbsp; The default RSP type is the REQ type, so RSP must be specified only if different than REQ.&nbsp; Required parameter for SV connections.</td></tr><tr><td class=CDLEntry>CVRT, CVRT_REQ, CVRT_RSP</td><td class=CDLDescription>The converter policy class to use for this connection (optional).&nbsp; In SV, you do not need to specify a converter for transaction types that extend <i>uvm_object</i> and implement the <i>do_pack</i> and <i>do_unpack</i> methods (or use the <i>`uvm_field</i> macros).&nbsp; In SC, you do not need to specify a converter for transaction types that implement <i>do_pack</i> and <i>do_unpack</i> or for which you have defined a template specialization of <i>uvmc_converter&lt;T&gt;</i>.&nbsp; See <a href="../converters/README-txt.html#Converters" class=LSection id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">Converters</a> for how to define and use converter classes.&nbsp; Default: <i>uvmc_converter #(X)</i>, with X = [T, REQ, or RSP]</td></tr></table><p>On the SC-side, you do not typically need to specify any type parameters.&nbsp; The transaction type is deduced by the C++ compiler based on the port provided, and converters are almost always a specialization of the default converter.&nbsp; The compiler choses any specialization over the default implementation automatically.</p></div></div></div>




 <!--CONTENT index=5 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Arguments" href="../../../uvmc/examples/connections/README.txt">Arguments</a></h3><div class=CBody><p>A description of the arguments to <i>connect</i>.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>port</td><td class=CDLDescription>The port, export, imp, interface, or socket instance to be connected.&nbsp; The port&rsquo;s hierarchical name will be registered as a lookup string for matching against other port registrations within both SV and SC.&nbsp; A string match between two registered ports results in those ports being connected.</td></tr><tr><td class=CDLEntry>lookup</td><td class=CDLDescription>An optional, additional lookup string to register for this port.&nbsp; Every UVMC connection must involve at least one usage of this optional string, as all ports have unique hierarchical names.&nbsp; Default: &ldquo;&rdquo;</td></tr></table><h4 class=CHeading>Port Argument</h4><p>The connect function&rsquo;s <i>port</i> argument is a handle to a TLM1 or TLM2 port, export, interface, imp, or socket.&nbsp; During elaboration, the matched port must agree on interface (e.g. put, get, peek), direction (e.g. port or export/imp), and transaction type, else the connection will fail.</p><p>For example, consider the following SV port</p><blockquote><pre>uvm_tlm_blocking_put_port #(trans)</pre></blockquote><p>This port can be connected via <i>connect</i> to instances of the following SC port types, assuming the appropriate converters exist.</p><blockquote><pre>tlm_blocking_put_if&lt;trans&gt;
sc_export&lt; tlm_blocking_put_if&lt;trans&gt; &gt;

tlm_put_if&lt;trans&gt;
sc_export&lt; tlm_put_if&lt;trans&gt; &gt;</pre></blockquote><p>The same SV port can be connected to the following SC port instances using the <i>connect_hier</i> function.</p><blockquote><pre>sc_port&lt; tlm_blocking_put_if&lt;trans&gt; &gt;
sc_port&lt; tlm_put_if&lt;trans&gt; &gt;</pre></blockquote><p>As you can see, the blocking put port in SV has several compatible connection options in SC.&nbsp; That&rsquo;s because the blocking put port requires a connection to something that provides a blocking put interface, a requirement satisfied by all the above SC-side exports and interfaces.</p><ul><li>The <i>tlm_blocking_put_if&lt;trans&gt;</i> meets this requirement exactly</li><li>The <i>tlm_put_if&lt;trans&gt;</i> interface provides an implementation of both the blocking put and non-blocking put interface, so it meets the blocking interface requirement</li><li>Each export is ultimately connected to implementations of the <i>tlm_blocking_put_if</i> or <i>tlm_put_if</i> interfaces</li></ul><p>Derivatives of the above export and interface types are also valid connections to our blocking put port.</p><h4 class=CHeading>Lookup Argument</h4><p>Lookup strings are global across both SC and SV.&nbsp; A lookup string can be anything you wish as long as it is unique to other UVMC connections.&nbsp; Just before UVM&rsquo;s <i>end_of_elaboration</i> phase, UVM Connect will establish the actual cross-language connection.</p><p>It is recommended that you apply a naming convention that assures the lookup strings will be unique yet do not embed hierarchical paths.</p><p>While most connections will be made by matching <i>lookup</i> strings, UVMC also captures each port&rsquo;s hierarchical name in each connect call.&nbsp; This hierarchical name can be used for matching as well.</p><p>Connecting by matching an SV port&rsquo;s hierarchical name</p><blockquote><pre>SV:
uvmc_tlm #()::connect(prod.out);

SC:
uvmc_connect(cons.in, &quot;prod.out&quot;);</pre></blockquote><p>The connect call in SV omits the 2nd argument.&nbsp; Therefore, UVMC only registers the hierarchical name, <i>&rdquo;prod.out&rdquo;</i> , to represent the producer&rsquo;s port.&nbsp; The connect call on the SC side supplies a 2nd argument.&nbsp; Thus, UVMC registers the names <i>&rdquo;cons.in&rdquo;</i> and <i>&rdquo;prod.out&rdquo;</i> to represent the consumer&rsquo;s export.&nbsp; During elaboration, UVM Connect will match the string <i>&rdquo;prod.out&rdquo;</i> and make the connection between the SV producer and the SC consumer.</p><p>This approach is not recommended because you end up coupling your code to component hierarchy.&nbsp;  If one side&rsquo;s hierarchy changes, your UVMC connections will need to updated.&nbsp;  Using the global, arbitrary lookup string, while not ideal, provides better protection from hierarchy changes.</p><p>If you prefer to use hierarchical names, you will have to specify at least one hierarchical name as the lookup string.</p><p>To avoid affecting the <i>connect</i> code when paths or lookup strings need to change, consider storing the paths and lookup strings in a separate file for reading/parsing rather than hard-coding them in your code.</p></div></div></div>




 <!--CONTENT index=6 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Usage" href="../../../uvmc/examples/connections/README.txt">Usage</a></h3><div class=CBody><p>The <i>connect</i> function registers a port for UVMC connection.&nbsp; During elaboration, the port&rsquo;s hierarchical name and optional lookup name will be used to match with lookup strings of other registered ports.&nbsp; During operation, transactions are converted using the default converter, or using the converter type you specified in the <i>connect</i> call.</p><p>Most ports require they be connected.&nbsp; Registering with UVMC <i>connect</i> satisfies this requirement.&nbsp; However, any UVMC connection that does not end up with a match will produce a fatal error.</p><p>While native connections require a single call to <i>connect</i> (SV) or <i>bind</i> (SC), a UVMC connection requires <i>two</i> connect calls, one each for the initiator and target, each of which can be in either SC or SV.</p></div></div></div>




 <!--CONTENT index=7 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="SV_Connections" href="../../../uvmc/examples/connections/README.txt">SV Connections</a></h3><div class=CBody><p>For SV, the connect function is a static member function of a class that is parameterized to the transaction type and optional converter.&nbsp; The transaction type is a required parameter, whereas the converter is only required if your transaction does not implement <i>do_pack</i> and <i>do_unpack</i> (or use the <i>`uvm_field</i> macros).</p><h4 class=CHeading>Point-to-point TLM2 or analysis connection</h4><blockquote><pre>uvmc_tlm #(trans)::connect(port_handle, &quot;lookup&quot;);</pre></blockquote><h4 class=CHeading>Hierarchical TLM2 connection</h4><blockquote><pre>uvmc_tlm1 #(trans)::connect_hier(port_handle, &quot;lookup&quot;);</pre></blockquote><h4 class=CHeading>Point-to-point unidirectional TLM1 connection</h4><blockquote><pre>uvmc_tlm1 #(trans)::connect(port_handle, &quot;lookup&quot;);</pre></blockquote><h4 class=CHeading>Point-to-point bidirectional TLM1 connection</h4><blockquote><pre>uvmc_tlm1 #(request, response)::connect(port_handle, &quot;lookup&quot;);</pre></blockquote><h4 class=CHeading>Hierarchical TLM1 connection</h4><blockquote><pre>uvmc_tlm1 #(trans)::connect_hier(port_handle, &quot;lookup&quot;);</pre></blockquote><h4 class=CHeading>Notes</h4><ul><li>These calls to connect do not specify a converter class explicitly.&nbsp; Therefore, the default converter will be used.&nbsp; See <a href="../converters/README-txt.html#Default_Converters" class=LGroup id=link3 onMouseOver="ShowTip(event, 'tt3', 'link3')" onMouseOut="HideTip('tt3')">Default Converters</a> for details.</li><li>Connections to analysis ports and exports is made using <i>uvmc_tlm #(trans)::connect</i>, not <i>uvmc_tlm1 #(trans)::connect</i>.</li><li>For TLM2 connections, if the <i>trans</i> type is not specified, the default <i>uvm_tlm_generic_payload</i> is used.</li><li>You must specify the <i>trans</i> type when making TLM1 connections, as there is no default transaction type for TLM1.</li></ul></div></div></div>




 <!--CONTENT index=8 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="SC_Connections" href="../../../uvmc/examples/connections/README.txt">SC Connections</a></h3><div class=CBody><p>UVMC connections in SystemC are made by registering any TLM port, export, interface, or socket using the <i>uvmc_connect</i> function.&nbsp; When calling this function, you pass in a reference to the TLM instance and an optional lookup string.&nbsp; During elaboration, UVMC will connect the ports whose registered lookup strings match.&nbsp; An error will occur if the ports are incompatible or a registered port has no match.</p><p>All UVMC TLM connections in SystemC are made with two kinds of connect calls.</p><h4 class=CHeading>Point-to-point connection (TLM2 and TLM1)</h4><blockquote><pre>uvmc_connect(port_ref, &quot;lookup&quot;);</pre></blockquote><h4 class=CHeading>Hierarchical connection (TLM2 and TLM1)</h4><blockquote><pre>uvmc_connect_hier(port_ref, &quot;lookup&quot;);</pre></blockquote><h4 class=CHeading>Notes</h4><ul><li>SC-side connects calls typically do not specify a converter type explicitly.&nbsp; In most cases, you will have defined a template specialization of the default converter, which the compiler choses automatically for you.&nbsp; See <a href="../converters/README-txt.html#Converters" class=LSection id=link4 onMouseOver="ShowTip(event, 'tt2', 'link4')" onMouseOut="HideTip('tt2')">Converters</a> for details on defining transaction converters.</li><li>You are not required to specify the port, interface, or transaction types because the C++ compiler will infer them by the port reference you provide to <i>uvmc_connect</i>.</li></ul></div></div></div>




 <!--CONTENT index=9 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Notes" href="../../../uvmc/examples/connections/README.txt">Notes</a></h3></div></div>




 <!--CONTENT index=10 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="One_UVMC_Connection_per_Port" href="../../../uvmc/examples/connections/README.txt">One UVMC Connection per Port</a></h3><div class=CBody><p>A UVMC connect call can be made only once for each port, export, imp, and socket instance, but this restriction does not limit your connectivity options.&nbsp; For example, an SV-side <i>uvm_tlm_analysis_port&lt;T&gt;</i> may drive any number of SC-side analysis imps or exports.&nbsp; The <i>uvmc_connect</i> call on the SC side returns a reference to the proxy port that will drive the specified SC-side analysis export/interface.&nbsp; You may subsequently bind this proxy port to any number of other SC-side exports/interfaces.</p></div></div></div>




 <!--CONTENT index=11 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="SC_connections_without_sc_main" href="../../../uvmc/examples/connections/README.txt">SC connections without sc_main</a></h3><div class=CBody><p>All SC examples in this kit all define the standard <i>sc_main</i> entry point to instantiate the SC-side testbench and start SystemC.&nbsp;  Your simulator may also support exportation of SC model definitions for direct instantiation in SystemVerilog.</p><p>The following demonstrates how to create a UVMC connection by defining and exporting a top-level <i>sc_module</i> to SystemVerilog.&nbsp; The SC module must be compiled and exported to a library before attempting to compile and link the SystemVerilog code.</p><h4 class=CHeading>SC side</h4><p>In SystemC, you define the sc_module, then invoke the <i>SC_EXPORT_MODULE</i> macro to export it.</p><blockquote><pre>sc_top.h:

class sc_top : public sc_module
{
   public:
   target trgt;
   SC_CTOR(sc_top) : trgt(&quot;trgt&quot;)
   {
     uvmc_connect(trgt.target_socket,&quot;foo&quot;);
   }
};

sc_top.cpp:

#include &quot;sc_top.h&quot;
SC_MODULE_EXPORT(sc_top)</pre></blockquote><h4 class=CHeading>SV side</h4><p>In SystemVerilog, you define the top-level SV module to instantiate the SC module as if it were an SV module.&nbsp; The location of the compiled and exported SC module must be visible to your SV compiler.</p><blockquote><pre>class sv_env extends uvm_env;
   initiator init;
   ...
   function void connect_phase(uvm_phase phase);
     uvmc_tlm#(payload)::connect(init.socket, &quot;foo&quot;);
   endfunction
endclass

...

module sv_top;
  // Instantiate export SC module
  sc_top sc_top_inst();
  initial begin
     sv_env env;
     env = new(&quot;env&quot;);
     run_test(&quot;test&quot;);
  end
endmodule</pre></blockquote><p>The above example shows the UVMC connection being registered in the <i>connect_phase</i> of the <i>sv_env</i> class.</p></div></div></div>




 <!--CONTENT index=12 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="SystemC_Starting_before_UVM_is_Ready" href="../../../uvmc/examples/connections/README.txt">SystemC Starting before UVM is Ready</a></h3><div class=CBody><p>SystemC may finish elaboration before SystemVerilog, in which case its models may start to emit transactions out its UVMC ports connections before UVM is ready to receive them.&nbsp; UVM Connect blocks all communication from SystemC until UVM has reached its run_phase.&nbsp; This means that all TLM port communication in SystemC must occur from an SystemC thread via <i>SC_THREAD</i> or <i>sc_spawn</i>.</p><p>To allow port registration to occur up through UVM&rsquo;s <i>connect_phase</i>, UVM&rsquo;s ILLCRT check is disabled to allow post-build UVMC port binding.</p></div></div></div>




 <!--CONTENT index=13 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Timescales" href="../../../uvmc/examples/connections/README.txt">Timescales</a></h3><div class=CBody><p>UVM Connect&rsquo;s default time precision for conveying delay times in the TLM2 interfaces is 1 picosecond.</p><p>Use Questa&rsquo;s <i>-t</i> argument in vsim to force the time scale in both SC and SV to be the same.&nbsp; Refer to the documentation for how to do this in other simulators.</p></div></div></div>




 <!--CONTENT index=14 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Connection_Examples" href="../../../uvmc/examples/connections/README.txt">Connection Examples</a></h3><div class=CBody><p>This section describes how to prepare and run the connection examples including in this kit.</p></div></div></div>




 <!--CONTENT index=15 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Setup" href="../../../uvmc/examples/connections/README.txt">Setup</a></h3><div class=CBody><p>See <a href="../../docs/OVERVIEW-txt.html#Getting_Started" class=LGroup id=link5 onMouseOver="ShowTip(event, 'tt1', 'link5')" onMouseOut="HideTip('tt1')">Getting Started</a> for setup requirements before running the examples.&nbsp; Specifically, you will need to have precompiled the UVM and UVMC libraries and set environment variables pointing to them.</p></div></div></div>




 <!--CONTENT index=16 -->
<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Running" href="../../../uvmc/examples/connections/README.txt">Running</a></h3><div class=CBody><h4 class=CHeading>Use <i>make help</i> to view the menu of available examples</h4><blockquote><pre>&gt; make help</pre></blockquote><p>You&rsquo;ll get a menu similar to the following</p><blockquote><pre> -----------------------------------------------------------------
|                 UVMC EXAMPLES - CONNECTIONS                     |
 -----------------------------------------------------------------
|                                                                 |
| Usage:                                                          |
|                                                                 |
|   make [UVM_HOME=path] [UVMC_HOME=path] &lt;example&gt;               |
|                                                                 |
| where &lt;example&gt; is one or more of:                              |
|                                                                 |
|   sv2sc        : SV producer --&gt; SC consumer                    |
|                  Connection is made via UVMC                    |
|                                                                 |
|   sc2sv        : SC producer --&gt; SV consumer                    |
|                  Connection is made via UVMC                    |
|                                                                 |
|   sv2sc2sv     : SV producer --&gt; SC consumer                    |
|                  Producer and consumer send transactions to     |
|                  scoreboard for comparison                      |
|                  Connections are made via UVMC                  |
|                                                                 |
|   sc_wraps_sv  : SC producer --&gt; SC consumer                    |
|                  Defines SC wrapper around SV model, uses       |
|                  UVMC connections inside the the wrapper to     |
|                  integrate the SV component. The wrapper        |
|                  appears as a native SC component.              |
|                  Consider integration of RTL models in SC.      |
|                                                                 |
|   sv2sv_native : SV producer --&gt; SV consumer                    |
|                  Connection is made via standard UVM in SV      |
|                                                                 |
|   sc2sc_native : SC producer --&gt; SC consumer                    |
|                  Connection is made via standard IEEE TLM in SC |
|                                                                 |
|   sv2sv_uvmc   : SV producer --&gt; SV consumer                    |
|                  Connection is made via UVMC. Semantically      |
|                  equivalent to sv2sv_native                     |
|                                                                 |
| UVM_HOME and UVMC_HOME specify the location of the source       |
| headers and macro definitions needed by the examples. You must  |
| specify their locations via UVM_HOME and UVMC_HOME environment  |
| variables or make command line options. Command line options    |
| override any envrionment variable settings.                     |
|                                                                 |
| The UVM and UVMC libraries must be compiled prior to running    |
| any example. If the libraries are not at their default location |
| (UVMC_HOME/lib) then you must specify their location via the    |
| UVM_LIB and/or UVMC_LIB environment variables or make command   |
| line options. Make command line options take precedence.        |
|                                                                 |
| Other options:                                                  |
|                                                                 |
|   all   : Run all examples                                      |
|   clean : Remove simulation files and directories               |
|   help  : Print this help information                           |
|                                                                 |
|                                                                 |
 -----------------------------------------------------------------</pre></blockquote><p>To run just one example</p><blockquote><pre>&gt; make sv2sc</pre></blockquote><p>This compiles and runs the <i>sv2sc</i> example, which demonstrates an SV producer sending TLM generic payload transactions to an SC consumer via TLM sockets.</p><p>The UVM source location is defined by the <i>UVM_HOME</i> environment variable, and the UVM and UVMC compiled libraries are searched at their default location, <i>../../lib/uvmc_lib</i>.</p><p>To run all examples</p><blockquote><pre>&gt; make all</pre></blockquote><p>The <i>clean</i> target deletes all the simulation files produced from previous runs.</p><blockquote><pre>&gt; make clean</pre></blockquote><p>You can combine targets in one command line</p><blockquote><pre>&gt; make clean sc_wraps_sv</pre></blockquote><p>The following runs the &lsquo;sc2sv&rsquo; example, providing the path to the UVM source and compiled library on the <i>make</i> command line.</p><blockquote><pre>&gt; make UVM_HOME=&lt;path&gt; UVM_LIB=&lt;path&gt; sc2sv</pre></blockquote><blockquote><pre>//------------------------------------------------------------//
//   Copyright 2009-2012 Mentor Graphics Corporation          //
//   All Rights Reserved Worldwid                             //
//                                                            //
//   Licensed under the Apache License, Version 2.0 (the      //
//   &quot;License&quot;); you may not use this file except in          //
//   compliance with the License.  You may obtain a copy of   //
//   the License at                                           //
//                                                            //
//       http://www.apache.org/licenses/LICENSE-2.0           //
//                                                            //
//   Unless required by applicable law or agreed to in        //
//   writing, software distributed under the License is       //
//   distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR   //
//   CONDITIONS OF ANY KIND, either express or implied.  See  //
//   the License for the specific language governing          //
//   permissions and limitations under the License.           //
//------------------------------------------------------------//</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CGroup>This section specifies the requirements for compiling and using the UVMC library and included examples.</div></div><div class=CToolTip id="tt2"><div class=CSection>This chapter shows how to write converters for your transactions. </div></div><div class=CToolTip id="tt3"><div class=CGroup>UVM Connect defines default converters in both SV and SC</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>