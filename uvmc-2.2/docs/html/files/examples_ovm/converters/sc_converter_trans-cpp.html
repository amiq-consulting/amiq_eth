<html><head><title>UVMC Converter Example - SC In-Transaction</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad()"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version Development Release 01-12-2008 (1.35 base) -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org --> 








 <!--TOP - START OF CONTENT-->
<div id=Content>


 <!--CONTENT index=0 -->
<div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle></h1>

<!--START_ND_SUMMARY index=0-->
<div class=Summary><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable>
  <!-- index=0 -->

<tr class="SMain"><td colspan=2 class=SEntry><a name="UVMC_Converter_Example-SC_In-Transaction"  href="../../../uvmc/examples_ovm/converters/sc_converter_trans.cpp">UVMC Converter Example - SC In-Transaction</a></td></tr>
<tr class=SMain><td colspan=2 class=SWideDescription>This example&rsquo;s packet class defines <i>do_pack</i> and <i>do_unpack</i> methods that are compatible with the default converter in SC. </td></tr>
  <!-- index=1 -->

<tr class="SGroup SIndent1"><td class=SEntry><a name="User_LibrarySummary"  href="#User_Library">User Library</a></td><td class=SDescription>This section defines a transaction class and generic consumer model. </td></tr>
  <!-- index=2 -->

<tr class="SGroup SIndent1"><td class=SEntry><a name="Conversion_codeSummary"  href="#Conversion_code">Conversion code</a></td><td class=SDescription>We do not need to define an external conversion class because it conversion is built into the transaction proper. </td></tr>
  <!-- index=3 -->

<tr class="SGroup SIndent1"><td class=SEntry><a name="Testbench_codeSummary"  href="#Testbench_code">Testbench code</a></td><td class=SDescription>This section defines our testbench environment. </td></tr></table></div></div><!--END_ND_SUMMARY-->
<div class=CBody><p>This example&rsquo;s packet class defines <i>do_pack</i> and <i>do_unpack</i> methods that are compatible with the default converter in SC.&nbsp; The default converter merely delegates conversion to these two methods in the transaction class.</p><img src="../../../images/UVMC_Converters_SC_InTrans.png" width="389" height="131"><p>This approach is not very common in practice, as it couples your transaction types to the UVMC library.</p><p>Instead of defining member functions of the transaction type to do conversion, you should instead implement a template specialization of uvmc_convert&lt;T&gt;.&nbsp; This leaves conversion knowledge outside your transaction proper, and allows you to define different conversion algorithms without requiring inheritance.</p></div></div></div>




 <!--CONTENT index=1 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="User_Library" href="../../../uvmc/examples_ovm/converters/sc_converter_trans.cpp">User Library</a></h3><div class=CBody><p>This section defines a transaction class and generic consumer model.&nbsp; The transaction implements the <i>do_pack</i> and <i>do_unpack</i> methods required by the default converter.</p><p>Packing and unpacking involves streaming the contents of your transaction fields into and out of the <i>packer</i> object provided as an argument to <i>do_pack</i> and <i>do_unpack</i>.&nbsp; The packer needs to have defined <i>operator&lt;&lt;</i> for each type of field you stream.&nbsp; See <a href="../../examples/field_types/README-txt.html#UVMC_Type_Support" class=LSection id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">UVMC Type Support</a> for a list of supported transaction field types.</p><blockquote><pre>namespace user_lib {

  using namespace uvmc;

  class packet_base
  {
    public:
    enum cmd_t { WRITE=0, READ, NOOP };

    cmd_t cmd;
    unsigned int addr;
    vector&lt;unsigned char&gt; data;

    virtual void do_pack(uvmc_packer &amp;packer) const {
      packer &lt;&lt; cmd &lt;&lt; addr &lt;&lt; data;
    }

    virtual void do_unpack(uvmc_packer &amp;packer) {
      packer &gt;&gt; cmd &gt;&gt; addr &gt;&gt; data;
    }
  };


  class packet : public packet_base
  {
    public:
    unsigned int extra_int;

    virtual void do_pack(uvmc_packer &amp;packer) const {
      packet_base::do_pack(packer);
      packer &lt;&lt; extra_int;
    }

    virtual void do_unpack(uvmc_packer &amp;packer) {
      packet_base::do_unpack(packer);
      packer &gt;&gt; extra_int;
    }
  };

  // a generic target with a TLM1 put export
  #include &quot;consumer.cpp&quot;

}</pre></blockquote></div></div></div>




 <!--CONTENT index=2 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Conversion_code" href="../../../uvmc/examples_ovm/converters/sc_converter_trans.cpp">Conversion code</a></h3><div class=CBody><p>We do not need to define an external conversion class because it conversion is built into the transaction proper.&nbsp; The default converter will delegate to our transaction&rsquo;s <i>do_pack</i> and <i>do_unpack</i> methods.</p><p>We do, however, define <i>operator&lt;&lt; (ostream&amp;)</i> for our transaction type using <a href="../../src/connect/sc/uvmc_macros-h.html#UVMC_PRINT" class=LGeneric id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">UVMC_PRINT</a> macros.&nbsp; With this, we can print the transaction contents to any output stream.</p><p>For example</p><blockquote><pre>packet p;
...initialize p...
cout &lt;&lt; p;</pre></blockquote><p>This produces output similar to</p><blockquote><pre>'{cmd:2 addr:1fa34f22 data:'{4a, 27, de, a2, 6b, 62, 8d, 1d, 6} }</pre></blockquote><p>You can invoke the macros in any namepace in which the uvmc namespace was imported and the macros #included.</p><blockquote><pre>using namespace user_lib;

UVMC_PRINT_3(packet_base,cmd,addr,data)
UVMC_PRINT_EXT_1(packet,packet_base,extra_int)</pre></blockquote></div></div></div>




 <!--CONTENT index=3 -->
<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Testbench_code" href="../../../uvmc/examples_ovm/converters/sc_converter_trans.cpp">Testbench code</a></h3><div class=CBody><p>This section defines our testbench environment.&nbsp; In the top-level  module, we instantiate the generic consumer model.&nbsp; We also register  the consumer&rsquo;s <i>in</i> export to have a UVMC connection with a lookup string, <i>stimulus</i>.&nbsp; The SV-side will register its producer&rsquo;s <i>out</i>  port with the same lookup string.&nbsp; UVMC will match these two strings to complete the cross-language connection, i.e. the SV producer&rsquo;s <i>out</i> port will be bound to the SC consumer&rsquo;s <i>in</i> export.</p><blockquote><pre>class sc_env : public sc_module
{
  public:
  consumer&lt;packet&gt; cons;

  sc_env(sc_module_name nm) : cons(&quot;cons&quot;) {
    uvmc_connect(cons.in,&quot;stimulus&quot;);
    uvmc_connect(cons.ap,&quot;checker&quot;);
  }
};

// Define sc_main, the vendor-independent means of starting a
// SystemC simulation.

int sc_main(int argc, char* argv[])
{
  sc_env env(&quot;env&quot;);
  sc_start();
  return 0;
}</pre></blockquote></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CSection>The members of your transaction definitions may be any collection of the following types, which have direct support in UVMC. </div></div><div class=CToolTip id="tt2"><div class=CGeneric>Generate an <i>operator&lt;&lt;(ostream&amp;)</i> implementation for use with <i>cout</i> and other output streams for the given transaction <i>TYPE</i>.</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>